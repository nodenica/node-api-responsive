<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Globals</title>
  <link rel="stylesheet" href="assets/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="assets/css/custom.css"/>
  <link rel="stylesheet" href="assets/css/style.css"/>
  <link rel="stylesheet" href="assets/css/sh_style.css"/>
</head>
<body>
  <div class="container">
<h1 id="global-objects">Global Objects</h1>
<!-- type=misc -->
<p>These objects are available in all modules. Some of these objects aren&#39;t
actually in the global scope but in the module scope - this will be noted.</p>
<h2 id="global">global</h2>
<!-- type=global -->
<ul>
<li>{Object} The global namespace object.</li>
</ul>
<p>In browsers, the top-level scope is the global scope. That means that in
browsers if you&#39;re in the global scope <code>var something</code> will define a global
variable. In Node this is different. The top-level scope is not the global
scope; <code>var something</code> inside a Node module will be local to that module.</p>
<h2 id="process">process</h2>
<!-- type=global -->
<ul>
<li>{Object}</li>
</ul>
<p>The process object. See the <a href="process.html#process_process">process object</a> section.</p>
<h2 id="console">console</h2>
<!-- type=global -->
<ul>
<li>{Object}</li>
</ul>
<p>Used to print to stdout and stderr. See the <a href="console.html">console</a> section.</p>
<h2 id="class-buffer">Class: Buffer</h2>
<!-- type=global -->
<ul>
<li>{Function}</li>
</ul>
<p>Used to handle binary data. See the <a href="buffer.html">buffer section</a></p>
<h2 id="require-">require()</h2>
<!-- type=var -->
<ul>
<li>{Function}</li>
</ul>
<p>To require modules. See the <a href="modules.html#modules_modules">Modules</a> section.  <code>require</code> isn&#39;t actually a
global but rather local to each module.</p>
<h3 id="require-resolve-">require.resolve()</h3>
<p>Use the internal <code>require()</code> machinery to look up the location of a module,
but rather than loading the module, just return the resolved filename.</p>
<h3 id="require-cache">require.cache</h3>
<ul>
<li>{Object}</li>
</ul>
<p>Modules are cached in this object when they are required. By deleting a key
value from this object, the next <code>require</code> will reload the module.</p>
<h3 id="require-extensions">require.extensions</h3>
<pre><code>Stability: 0 - Deprecated
</code></pre><ul>
<li>{Object}</li>
</ul>
<p>Instruct <code>require</code> on how to handle certain file extensions.</p>
<p>Process files with the extension <code>.sjs</code> as <code>.js</code>:</p>
<pre><code>require.extensions[&#39;.sjs&#39;] = require.extensions[&#39;.js&#39;];
</code></pre><p><strong>Deprecated</strong>  In the past, this list has been used to load
non-JavaScript modules into Node by compiling them on-demand.
However, in practice, there are much better ways to do this, such as
loading modules via some other Node program, or compiling them to
JavaScript ahead of time.</p>
<p>Since the Module system is locked, this feature will probably never go
away.  However, it may have subtle bugs and complexities that are best
left untouched.</p>
<h2 id="__filename">__filename</h2>
<!-- type=var -->
<ul>
<li>{String}</li>
</ul>
<p>The filename of the code being executed.  This is the resolved absolute path
of this code file.  For a main program this is not necessarily the same
filename used in the command line.  The value inside a module is the path
to that module file.</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>
<pre><code>console.log(__filename);
// /Users/mjr/example.js
</code></pre><p><code>__filename</code> isn&#39;t actually a global but rather local to each module.</p>
<h2 id="__dirname">__dirname</h2>
<!-- type=var -->
<ul>
<li>{String}</li>
</ul>
<p>The name of the directory that the currently executing script resides in.</p>
<p>Example: running <code>node example.js</code> from <code>/Users/mjr</code></p>
<pre><code>console.log(__dirname);
// /Users/mjr
</code></pre><p><code>__dirname</code> isn&#39;t actually a global but rather local to each module.</p>
<h2 id="module">module</h2>
<!-- type=var -->
<ul>
<li>{Object}</li>
</ul>
<p>A reference to the current module. In particular
<code>module.exports</code> is used for defining what a module exports and makes
available through <code>require()</code>.</p>
<p><code>module</code> isn&#39;t actually a global but rather local to each module.</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.</p>
<h2 id="exports">exports</h2>
<!-- type=var -->
<p>A reference to the <code>module.exports</code> that is shorter to type.
See <a href="modules.html">module system documentation</a> for details on when to use <code>exports</code> and
when to use <code>module.exports</code>.</p>
<p><code>exports</code> isn&#39;t actually a global but rather local to each module.</p>
<p>See the <a href="modules.html">module system documentation</a> for more information.</p>
<p>See the <a href="modules.html">module section</a> for more information.</p>
<h2 id="settimeout-cb-ms-">setTimeout(cb, ms)</h2>
<p>Run callback <code>cb</code> after <em>at least</em> <code>ms</code> milliseconds. The actual delay depends
on external factors like OS timer granularity and system load.</p>
<p>The timeout must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.</p>
<p>Returns an opaque value that represents the timer.</p>
<h2 id="cleartimeout-t-">clearTimeout(t)</h2>
<p>Stop a timer that was previously created with <code>setTimeout()</code>. The callback will
not execute.</p>
<h2 id="setinterval-cb-ms-">setInterval(cb, ms)</h2>
<p>Run callback <code>cb</code> repeatedly every <code>ms</code> milliseconds. Note that the actual
interval may vary, depending on external factors like OS timer granularity and
system load. It&#39;s never less than <code>ms</code> but it may be longer.</p>
<p>The interval must be in the range of 1-2,147,483,647 inclusive. If the value is
outside that range, it&#39;s changed to 1 millisecond. Broadly speaking, a timer
cannot span more than 24.8 days.</p>
<p>Returns an opaque value that represents the timer.</p>
<h2 id="clearinterval-t-">clearInterval(t)</h2>
<p>Stop a timer that was previously created with <code>setInterval()</code>. The callback
will not execute.</p>
<!--type=global-->
<p>The timer functions are global variables. See the <a href="timers.html">timers</a> section.</p>
</div>
<script src="assets/js/sh.js" type="text/javascript"></script>
</body>
</html>
