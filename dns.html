<!DOCTYPE html>
<html>
<head>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>DNS</title>
  <link rel="stylesheet" href="assets/css/bootstrap.min.css"/>
  <link rel="stylesheet" href="assets/css/custom.css"/>
  <link rel="stylesheet" href="assets/css/style.css"/>
  <link rel="stylesheet" href="assets/css/sh_style.css"/>
</head>
<body>
  <div class="container">
<h1 id="dns">DNS</h1>
<pre><code>Stability: 3 - Stable
</code></pre><p>Use <code>require(&#39;dns&#39;)</code> to access this module.</p>
<p>This module contains functions that belong to two different categories:</p>
<p>1) Functions that use the underlying operating system facilities to perform
name resolution, and that do not necessarily do any network communication.
This category contains only one function: <code>dns.lookup</code>. <strong>Developers looking
to perform name resolution in the same way that other applications on the same
operating system behave should use <code>dns.lookup</code>.</strong></p>
<p>Here is an example that does a lookup of <code>www.google.com</code>.</p>
<pre><code>var dns = require(&#39;dns&#39;);

dns.lookup(&#39;www.google.com&#39;, function onLookup(err, addresses, family) {
  console.log(&#39;addresses:&#39;, addresses);
});
</code></pre><p>2) Functions that connect to an actual DNS server to perform name resolution,
and that <em>always</em> use the network to perform DNS queries. This category
contains all functions in the <code>dns</code> module but <code>dns.lookup</code>. These functions
do not use the same set of configuration files than what <code>dns.lookup</code> uses.
For instance, <em>they do not use the configuration from <code>/etc/hosts</code></em>. These
functions should be used by developers who do not want to use the underlying
operating system&#39;s facilities for name resolution, and instead want to
<em>always</em> perform DNS queries.</p>
<p>Here is an example which resolves <code>&#39;www.google.com&#39;</code> then reverse
resolves the IP addresses which are returned.</p>
<pre><code>var dns = require(&#39;dns&#39;);

dns.resolve4(&#39;www.google.com&#39;, function (err, addresses) {
  if (err) throw err;

  console.log(&#39;addresses: &#39; + JSON.stringify(addresses));

  addresses.forEach(function (a) {
    dns.reverse(a, function (err, domains) {
      if (err) {
        throw err;
      }

      console.log(&#39;reverse for &#39; + a + &#39;: &#39; + JSON.stringify(domains));
    });
  });
});
</code></pre><p>There are subtle consequences in choosing one or another, please consult the
<a href="#dns_implementation_considerations">Implementation considerations section</a>
for more information.</p>
<h2 id="dns-lookup-domain-family-callback-">dns.lookup(domain, [family], callback)</h2>
<p>Resolves a domain (e.g. <code>&#39;google.com&#39;</code>) into the first found A (IPv4) or
AAAA (IPv6) record.
The <code>family</code> can be the integer <code>4</code> or <code>6</code>. Defaults to <code>null</code> that indicates
both Ip v4 and v6 address family.</p>
<p>The callback has arguments <code>(err, address, family)</code>.  The <code>address</code> argument
is a string representation of a IP v4 or v6 address. The <code>family</code> argument
is either the integer 4 or 6 and denotes the family of <code>address</code> (not
necessarily the value initially passed to <code>lookup</code>).</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is the error code.
Keep in mind that <code>err.code</code> will be set to <code>&#39;ENOENT&#39;</code> not only when
the domain does not exist but also when the lookup fails in other ways
such as no available file descriptors.</p>
<p><code>dns.lookup</code> doesn&#39;t necessarily have anything to do with the DNS protocol.
It&#39;s only an operating system facility that can associate name with addresses,
and vice versa.</p>
<p>Its implementation can have subtle but important consequences on the behavior
of any Node.js program. Please take some time to consult the <a href="#dns_implementation_considerations">Implementation
considerations section</a> before using it.</p>
<h2 id="dns-resolve-domain-rrtype-callback-">dns.resolve(domain, [rrtype], callback)</h2>
<p>Resolves a domain (e.g. <code>&#39;google.com&#39;</code>) into an array of the record types
specified by rrtype. Valid rrtypes are <code>&#39;A&#39;</code> (IPV4 addresses, default),
<code>&#39;AAAA&#39;</code> (IPV6 addresses), <code>&#39;MX&#39;</code> (mail exchange records), <code>&#39;TXT&#39;</code> (text
records), <code>&#39;SRV&#39;</code> (SRV records), <code>&#39;PTR&#39;</code> (used for reverse IP lookups),
<code>&#39;NS&#39;</code> (name server records) and <code>&#39;CNAME&#39;</code> (canonical name records).</p>
<p>The callback has arguments <code>(err, addresses)</code>.  The type of each item
in <code>addresses</code> is determined by the record type, and described in the
documentation for the corresponding lookup methods below.</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.</p>
<h2 id="dns-resolve4-domain-callback-">dns.resolve4(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for IPv4 queries (<code>A</code> records).
<code>addresses</code> is an array of IPv4 addresses (e.g.
<code>[&#39;74.125.79.104&#39;, &#39;74.125.79.105&#39;, &#39;74.125.79.106&#39;]</code>).</p>
<h2 id="dns-resolve6-domain-callback-">dns.resolve6(domain, callback)</h2>
<p>The same as <code>dns.resolve4()</code> except for IPv6 queries (an <code>AAAA</code> query).</p>
<h2 id="dns-resolvemx-domain-callback-">dns.resolveMx(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for mail exchange queries (<code>MX</code> records).</p>
<p><code>addresses</code> is an array of MX records, each with a priority and an exchange
attribute (e.g. <code>[{&#39;priority&#39;: 10, &#39;exchange&#39;: &#39;mx.example.com&#39;},...]</code>).</p>
<h2 id="dns-resolvetxt-domain-callback-">dns.resolveTxt(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for text queries (<code>TXT</code> records).
<code>addresses</code> is an array of the text records available for <code>domain</code> (e.g.,
<code>[&#39;v=spf1 ip4:0.0.0.0 ~all&#39;]</code>).</p>
<h2 id="dns-resolvesrv-domain-callback-">dns.resolveSrv(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for service records (<code>SRV</code> records).
<code>addresses</code> is an array of the SRV records available for <code>domain</code>. Properties
of SRV records are priority, weight, port, and name (e.g.,
<code>[{&#39;priority&#39;: 10, {&#39;weight&#39;: 5, &#39;port&#39;: 21223, &#39;name&#39;: &#39;service.example.com&#39;}, ...]</code>).</p>
<h2 id="dns-resolvens-domain-callback-">dns.resolveNs(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for name server records (<code>NS</code> records).
<code>addresses</code> is an array of the name server records available for <code>domain</code>
(e.g., <code>[&#39;ns1.example.com&#39;, &#39;ns2.example.com&#39;]</code>).</p>
<h2 id="dns-resolvecname-domain-callback-">dns.resolveCname(domain, callback)</h2>
<p>The same as <code>dns.resolve()</code>, but only for canonical name records (<code>CNAME</code>
records). <code>addresses</code> is an array of the canonical name records available for
<code>domain</code> (e.g., <code>[&#39;bar.example.com&#39;]</code>).</p>
<h2 id="dns-reverse-ip-callback-">dns.reverse(ip, callback)</h2>
<p>Reverse resolves an ip address to an array of domain names.</p>
<p>The callback has arguments <code>(err, domains)</code>.</p>
<p>On error, <code>err</code> is an <code>Error</code> object, where <code>err.code</code> is
one of the error codes listed below.</p>
<h2 id="error-codes">Error codes</h2>
<p>Each DNS query can return one of the following error codes:</p>
<ul>
<li><code>dns.NODATA</code>: DNS server returned answer with no data.</li>
<li><code>dns.FORMERR</code>: DNS server claims query was misformatted.</li>
<li><code>dns.SERVFAIL</code>: DNS server returned general failure.</li>
<li><code>dns.NOTFOUND</code>: Domain name not found.</li>
<li><code>dns.NOTIMP</code>: DNS server does not implement requested operation.</li>
<li><code>dns.REFUSED</code>: DNS server refused query.</li>
<li><code>dns.BADQUERY</code>: Misformatted DNS query.</li>
<li><code>dns.BADNAME</code>: Misformatted domain name.</li>
<li><code>dns.BADFAMILY</code>: Unsupported address family.</li>
<li><code>dns.BADRESP</code>: Misformatted DNS reply.</li>
<li><code>dns.CONNREFUSED</code>: Could not contact DNS servers.</li>
<li><code>dns.TIMEOUT</code>: Timeout while contacting DNS servers.</li>
<li><code>dns.EOF</code>: End of file.</li>
<li><code>dns.FILE</code>: Error reading file.</li>
<li><code>dns.NOMEM</code>: Out of memory.</li>
<li><code>dns.DESTRUCTION</code>: Channel is being destroyed.</li>
<li><code>dns.BADSTR</code>: Misformatted string.</li>
<li><code>dns.BADFLAGS</code>: Illegal flags specified.</li>
<li><code>dns.NONAME</code>: Given hostname is not numeric.</li>
<li><code>dns.BADHINTS</code>: Illegal hints flags specified.</li>
<li><code>dns.NOTINITIALIZED</code>: c-ares library initialization not yet performed.</li>
<li><code>dns.LOADIPHLPAPI</code>: Error loading iphlpapi.dll.</li>
<li><code>dns.ADDRGETNETWORKPARAMS</code>: Could not find GetNetworkParams function.</li>
<li><code>dns.CANCELLED</code>: DNS query cancelled.</li>
</ul>
<h2 id="implementation-considerations">Implementation considerations</h2>
<p>Although <code>dns.lookup</code> and <code>dns.resolve*/dns.reverse</code> functions have the same
goal of associating a network name with a network address (or vice versa),
their behavior is quite different. These differences can have subtle but
significant consequences on the behavior of Node.js programs.</p>
<h3 id="dns-lookup">dns.lookup</h3>
<p>Under the hood, <code>dns.lookup</code> uses the same operating system facilities as most
other programs. For instance, <code>dns.lookup</code> will almost always resolve a given
name the same way as the <code>ping</code> command. On most POSIX-like operating systems,
the behavior of the <code>dns.lookup</code> function can be tweaked by changing settings
in <code>nsswitch.conf(5)</code> and/or <code>resolv.conf(5)</code>, but be careful that changing
these files will change the behavior of all other programs running on the same
operating system.</p>
<p>Though the call will be asynchronous from JavaScript&#39;s perspective, it is
implemented as a synchronous call to <code>getaddrinfo(3)</code> that runs on libuv&#39;s
threadpool. Because libuv&#39;s threadpool has a fixed size, it means that if for
whatever reason the call to <code>getaddrinfo(3)</code> takes a long time, other
operations that could run on libuv&#39;s threadpool (such as filesystem
operations) will experience degraded performance. In order to mitigate this
issue, one potential solution is to increase the size of libuv&#39;s threadpool by
setting the &#39;UV_THREADPOOL_SIZE&#39; environment variable to a value greater than
4 (its current default value). For more information on libuv&#39;s threadpool, see
<a href="http://docs.libuv.org/en/latest/threadpool.html">the official libuv
documentation</a>.</p>
<h3 id="dns-resolve-functions-starting-with-dns-resolve-and-dns-reverse">dns.resolve, functions starting with dns.resolve and dns.reverse</h3>
<p>These functions are implemented quite differently than <code>dns.lookup</code>. They do
not use <code>getaddrinfo(3)</code> and they <em>always</em> perform a DNS query on the network.
This network communication is always done asynchronously, and does not use
libuv&#39;s threadpool.</p>
<p>As a result, these functions cannot have the same negative impact on other
processing that happens on libuv&#39;s threadpool that <code>dns.lookup</code> can have.</p>
<p>They do not use the same set of configuration files than what <code>dns.lookup</code>
uses. For instance, <em>they do not use the configuration from <code>/etc/hosts</code></em>.</p>
</div>
<script src="assets/js/sh.js" type="text/javascript"></script>
</body>
</html>
